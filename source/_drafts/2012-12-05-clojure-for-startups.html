---
layout: post
title: "Clojure for Startups"
date: 2012-12-05T02:24:00-08:00
comments: false
---

<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on"> There are few characteristics about Clojure that make it IMHO the best language for a startup (and possibly the best language already, but for the purposes of this article I won't try to argue that).  When looking for my next language I laid out a list of language features that I thought made coding faster.  Implicit in this process was the idea that all other things being equal, code that I could produce faster, and maintain faster would be worth more money.  Yes, more money, because at the end of the day that's why I code.  You could substitute the word "value" for "money" as well.  * simple, straight-forward syntax * a language that encourages loose coupling * avoidance of mutability * easy automated testablity * Homoiconicity * a REPL * easy language introspection * ease of code de-duplication * less code * a large mass of battle-tested libraries for common problems * a powerful editor or IDE  <h3>simple, straight-forward syntax</h3> So straight away languages like Scala were out of the running.  Instead a language like a Lisp has already got a lot of points in my scoring system because the syntax is very minimal; special cases are almost non-existant; and in Clojure the built=in libraries are very consistent.  For examples, in higher-order functions that operate on seqs 99.9% of them put the function as the first arg and the seq as the second.  I like consistency, it makes my life easier; I don't have to spend my time thinking about language and library gotchas, and can just bang out good code.  <h3>encourages loose coupling</h3> The enemy of code changeability is coupling. (Just like the enemy of my bachelorhood, but that's a convo for another place and time.)  For example, abstract base-classes are intermix two concepts and just aren't worth the supposed benefits.   1. code de-duplication 2. polymorphism   Clojure instead chooses to allow you to get both of these features "a la carte", meaning you can pick and choose freely any combination of the two.  The Clojure approach would be to use functions to de-duplicate the code, and then use multi-methods or protocols to introduce polymorphism.  (And not only that but they also enable a form of namespace scoped monkey-patching.  Amazing stuff.  Monkey patching's power, namespacing's sanity.)  <h3>avoidance of mutability</h3> In some ways mutability is related to loose coupling.  The mutability introduces coupling between time and value.  By this I mean that now we cannot just look at a value and know what it is, we have to also know what series of changes have already happened to it.    Mutability also introduces complexity. We always know that the value 1 is... well 1.  But a variable, `n` can technically be ANY number.  Suddenly you have a lot more edge caes to consider.  Mutability actually has some pretty nasty consequences for automated testing as well...  <h3>easy automated testablity</h3> In OO, a common pattern for a test case is:  GIVEN some state WHEN I hit a method on my object THEN there is some change in the state of the object OR some value is returned from that method  Since there is so little mutability in programming Clojure, in practice many more of your Clojure tests can be written as:  WHEN I call my function with some args THEN it returns a value  Depending on how you choose to count, this can be a reduction in work on the testing side of things by 50%.  You loose the GIVEN step which is often a disproportionate amount more work than the WHEN/THEN portions because of the intricacies of setting up the object under test. Also, you don't have to worry about changes to the object's state.  All of this stuff means you can be more sure your code works, which means it can continually churn out value (money) while you work on other code :)  <h3>Homoiconicity</h3> Since Clojure's source code is constructed out of Clojure data structures you may find yourself generating code in the REPL that you will then paste in to use as, for example, test data.  Macros enable us to write Lisp code that not only generates other Lisp code, but expands into that Lisp code before evaluation.  You can easily write handy functions to generate scaffolding code for example, like this code taken from my library <a href="https://github.com/runa-dev/clj-schema">clj-schema</a>:  <script class="brush: clj; gutter: false;" type="syntaxhighlighter"><![CDATA[ (defn scaffold-schema   "Makes a simple scaffolding schema from a given map m.    Each path has a validator of Anything."   [schema-name m]   (list 'defschema (symbol schema-name)         (vec (interleave (sort (u/paths m))                          (repeat 'Anything)))))  (scaffold-schema "foo" {:a 1234 :b {:c "asdf"}}) ;; => '(defschema foo          [[:a] Anything           [:b :c] Anything]) ]]></script>       Being able to write helper functions like this compounds your programming ability.   <h3>a REPL</h3> This is all about creating quick feedback loops. Quick feedback loops are a good way to prevent waste, because you can catch issues much sooner, and thus prevent yourself from diving deep into a issue, before realizing you made some mistake.  But with Clojure that's really just the beginning. Because Clojure itself is quite introspectable, it enables doc strings to be available at the REPL, and also easy introspection of a namespace's vars, or a Java object's methods.   <h3>ease of code de-duplication</h3>   <h3>less code</h3>With each line of code you need to write and/or maintain the number of time to write it increases as well as the time to debug and maintain it.  Less code is therefore less expensive. Startups need that monetary boost.   <h3></h3><h3></h3>  <h3>Summary</h3>   Clojure is:   * very practical and pragmatic, but also very flexible.  * very powerful yet very simple  </div></div>
